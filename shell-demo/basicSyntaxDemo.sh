#!/usr/bin/env bash

# shell中$0,$?,$!等的特殊用法

# 变量说明:
# $$
# Shell本身的PID（ProcessID）
# $!
# Shell最后运行的后台Process的PID
# $?
# 最后运行的命令的结束代码（返回值）
# $-
# 使用Set命令设定的Flag一览
# $*
# 所有参数列表。如"$*"用「"」括起来的情况、以"$1 $2 … $n"的形式输出所有参数。
# $@
# 所有参数列表。如"$@"用「"」括起来的情况、以"$1" "$2" … "$n" 的形式输出所有参数。
# $#
# 添加到Shell的参数个数
# $0
# Shell本身的文件名
# $1～$n

echo $$

echo date &

echo $!

echo $0

# 运算
# $((…))是用于进行整型运算的。在$((…))中，我们并不需要对变量加上$来表示它的值，也不需要预先声明这个变量是个整型。在双引号下也能进行有效运算。下面是个例子：
# #declare -i aa=13
# aa=13
# echo '$((aa-3))'=$((aa-3))
# echo '$(($aa-3))'=$(($aa-3))
# 也支持$((x += 2))的格式，包括下面几种操作。在下面的例子中我们引用了上面aa=13。
# ++ ：$((aa++))为13，并将aa赋值为14，注意使用$(($aa++))会报错，无法解析13++的含义，所以为了简洁并且不产生错误，不在运算式中加入$，如果是$((++aa))为14，并将aa赋值为14，这与C语言是一样的。
# -- ：$((aa--))为13，并将aa赋值为12，如果是$((--aa))为12，并将aa赋值为12。
# +
# -
# *
# /
# %：求余：$((aa%5))=3
# **：这个在C语言中是没有的，表示Exponentiation，即取幂。例如上面例子中$(($aa**3))相当于13*13*13=2197
# <<
# >>
# &
# |
# ~
# !
# ^
# 在[ … ]，>,<,=等符号是用于判断字符串的，表示用于比较数字的，在[ … ]中，如果对数字进行比较，
# 需要使用-lt, –gt, –le, –ge, –eq, –ne 。使用[ … ]，例如if [ 3 –gt 20 ]; then，条件不成立，但是[ 3 > 20 ]，则成立，因为此刻比较的是字符串
# 对于数学运算的赋值，使用$((...))有时显的比较繁复，可以使用let，格式如下：
# let intvar =expression
#　let表示expression是个数学运算，无须使用$(())来作进一步表明，这样的赋值方式简洁很多。 等号前后是没有空格的，在expression的表达式中也是没有空格的，如果有空格必须用引号引起来，可以是单引号，也可以是双引号，let x=1+4；let x='1 + 4'；let x="1 + 4"，这三个同样都是给x赋值为5
x=3
echo $((x>1))
echo $((x>3))

if ((x>1));then
    echo "OK"
fi
